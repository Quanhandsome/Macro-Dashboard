<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Macro Dashboard — improved data handling</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{--bg:#f7f8fb;--card:#fff;--muted:#6b7280}
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#111}
    header{position:sticky;top:0;background:var(--card);padding:12px 16px;border-bottom:1px solid #eee;display:flex;gap:12px;align-items:center;z-index:10}
    main{padding:18px;max-width:1200px;margin:0 auto;display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:900px){main{grid-template-columns:1fr 1fr}}
    .card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(16,24,40,0.04);min-height:360px}
    h1{font-size:18px;margin:0}
    .subtitle{color:var(--muted);font-size:13px;margin:6px 0 12px}
    select{padding:6px 8px;border-radius:8px;border:1px solid #ddd;background:#fff}
    canvas{width:100% !important;height:300px !important}
    #status{position:fixed;right:12px;bottom:12px;max-width:520px;background:#111;color:#fff;padding:10px 12px;border-radius:10px;font-size:12px;line-height:1.4;white-space:pre-wrap;box-shadow:0 10px 30px rgba(0,0,0,0.25)}
    #status.hidden{display:none}
  </style>
</head>
<body>
  <header>
    <h1>Macro Dashboard — improved</h1>
    <div style="margin-left:auto;display:flex;align-items:center;gap:10px">
      <label>Timeframe:
        <select id="timeframe">
          <option value="m">Month</option>
          <option value="q">Quarter</option>
          <option value="a">Year</option>
          <option value="w">Week</option>
        </select>
      </label>
    </div>
  </header>

  <div id="status" class="hidden"></div>

  <main>
    <section class="card">
      <h3>Prices & Inflation</h3>
      <p class="subtitle">CPI, Core CPI, PCE, Core PCE — plotted as YoY %</p>
      <canvas id="inflationChart"></canvas>
    </section>

    <section class="card">
      <h3>Policy & Yield Curve</h3>
      <p class="subtitle">Fed Funds Rate, 10Y-2Y spread</p>
      <canvas id="policyChart"></canvas>
    </section>

    <section class="card">
      <h3>Money & Balance Sheet</h3>
      <p class="subtitle">M2, Fed Assets (WALCL)</p>
      <canvas id="moneyChart"></canvas>
    </section>

    <section class="card">
      <h3>Growth & Activity</h3>
      <p class="subtitle">GDP (q), Industrial Production, Retail Sales</p>
      <canvas id="growthChart"></canvas>
    </section>

    <section class="card">
      <h3>Surveys & Sentiment</h3>
      <p class="subtitle">ISM PMI, UMich Consumer Sentiment</p>
      <canvas id="sentimentChart"></canvas>
    </section>

    <section class="card">
      <h3>Equities</h3>
      <p class="subtitle">S&P 500 (price)</p>
      <canvas id="equityChart"></canvas>
    </section>

    <section class="card">
      <h3>Commodities & USD</h3>
      <p class="subtitle">Gold (PM), WTI, Broad USD</p>
      <canvas id="commoditiesChart"></canvas>
    </section>

    <section class="card">
      <h3>Crypto</h3>
      <p class="subtitle">Bitcoin — fetch from CoinGecko (preferred)</p>
      <canvas id="btcChart"></canvas>
    </section>
  </main>

<script>
/* ===== CONFIG ===== */
const FRED_KEY = "2a302371de3d9e50c4820b561604a060"; // bro cung cấp
const MAX_POINTS = 24;
const TODAY = new Date();
const STATUS = document.getElementById('status');

/* ===== Series with native frequency (used for YoY lag & expectations) =====
   freq: 'd' daily, 'w' weekly, 'm' monthly, 'q' quarterly, 'a' annual
*/
const SERIES = {
  inflation: [
    {id:"CPIAUCSL", label:"CPI (All Items)", transform:'yoy', freq:'m'},
    {id:"CPILFESL", label:"Core CPI", transform:'yoy', freq:'m'},
    {id:"PCEPI", label:"PCE Price Index", transform:'yoy', freq:'m'},
    {id:"PCEPILFE", label:"Core PCE", transform:'yoy', freq:'m'}
  ],
  policy: [
    {id:"FEDFUNDS", label:"Fed Funds Rate", transform:'level', freq:'m'},
    {id:"T10Y2Y", label:"10Y-2Y Spread", transform:'level', freq:'d'}
  ],
  money: [
    {id:"M2SL", label:"M2 (Level)", transform:'level', freq:'m'},
    {id:"WALCL", label:"Fed Assets (WALCL)", transform:'level', freq:'w'}
  ],
  growth: [
    {id:"GDP", label:"GDP (SAAR)", transform:'level', freq:'q'},
    {id:"INDPRO", label:"Industrial Production", transform:'level', freq:'m'},
    {id:"RSAFS", label:"Retail Sales (Advance)", transform:'level', freq:'m'}
  ],
  sentiment: [
    {id:"NAPM", label:"ISM PMI", transform:'level', freq:'m'},
    {id:"UMCSENT", label:"UMich Sentiment", transform:'level', freq:'m'}
  ],
  equity: [
    {id:"SP500", label:"S&P 500", transform:'level', freq:'d'}
  ],
  commodities: [
    {id:"GOLDPMGBD228NLBM", label:"Gold (PM Fix USD/oz)", transform:'level', freq:'d'},
    {id:"DCOILWTICO", label:"WTI Crude (USD/bbl)", transform:'level', freq:'d'},
    {id:"DTWEXBGS", label:"Broad USD Index", transform:'level', freq:'d'}
  ],
  btc: [
    // We will fetch BTC from CoinGecko; keep this id as marker
    {id:"COINGECKO_BTC", label:"Bitcoin (USD)", transform:'price', freq:'d'}
  ]
};

/* ===== Proxy chain (fallback) ===== */
const PROXIES = [
  url => url,
  url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
  url => `https://r.jina.ai/https/${url.replace(/^https?:\/\//,'')}`,
  url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
  url => `https://thingproxy.freeboard.io/fetch/${url}`
];

function logStatus(msg, isError=false){
  STATUS.classList.remove('hidden');
  STATUS.textContent = (STATUS.textContent? STATUS.textContent + "\n":"") + (isError? "⚠️ ":"ℹ️ ") + msg;
}
function clearStatus(){ STATUS.textContent=''; STATUS.classList.add('hidden'); }
function iso(d){ return d.toISOString().split('T')[0]; }
function monthsAgo(n){ const x=new Date(); x.setMonth(x.getMonth()-n); return x; }
function yearsAgo(n){ const x=new Date(); x.setFullYear(x.getFullYear()-n); return x; }
function weeksAgo(n){ const x=new Date(); x.setDate(x.getDate()-7*n); return x; }

/* ===== Bucketing helpers ===== */
function toBucket(dateStr, freq){
  const [y,m,day] = dateStr.split('-').map(x=>parseInt(x,10));
  if (freq === 'a') return String(y);
  if (freq === 'q'){ const q = Math.floor((m-1)/3)+1; return `${y}-Q${q}`; }
  if (freq === 'm') return `${y}-${String(m).padStart(2,'0')}`;
  if (freq === 'w'){
    const dt = new Date(dateStr);
    const tmp = new Date(Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate()));
    const dayNum = (tmp.getUTCDay() + 6) % 7;
    tmp.setUTCDate(tmp.getUTCDate() - dayNum + 3);
    const firstThursday = new Date(Date.UTC(tmp.getUTCFullYear(),0,4));
    const weekNum = 1 + Math.round(((tmp - firstThursday)/86400000 - 3)/7);
    return `${tmp.getUTCFullYear()}-W${String(weekNum).padStart(2,'0')}`;
  }
  return dateStr;
}
function sortBuckets(arr){
  return arr.sort((A,B)=>{
    if (!A.includes('-') && !B.includes('-')) return parseInt(A)-parseInt(B);
    if (A.includes('-Q') || B.includes('-Q')){
      const [ay,aq] = A.split('-Q'); const [by,bq] = B.split('-Q');
      const ayN=parseInt(ay), byN=parseInt(by); const aqN=parseInt(aq||0), bqN=parseInt(bq||0);
      return ayN===byN ? aqN-bqN : ayN-byN;
    }
    if (A.includes('-W') || B.includes('-W')){
      const [ay,aw] = A.split('-W'); const [by,bw] = B.split('-W');
      const ayN=parseInt(ay), byN=parseInt(by); const awN=parseInt(aw||0), bwN=parseInt(bw||0);
      return ayN===byN ? awN-bwN : ayN-byN;
    }
    if (A.includes('-') && B.includes('-')){
      const [ay,am] = A.split('-').map(x=>parseInt(x)); const [by,bm] = B.split('-').map(x=>parseInt(x));
      return ay===by ? am-bm : ay-by;
    }
    return A.localeCompare(B);
  });
}
function generateBucketsForFreq(freq){
  const buckets=[];
  if (freq === 'm'){ for (let i=MAX_POINTS-1;i>=0;i--){ const d = monthsAgo(i); buckets.push(`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`);} }
  else if (freq === 'q'){ for (let i=MAX_POINTS-1;i>=0;i--){ const d = monthsAgo(i*3); const q=Math.floor(d.getMonth()/3)+1; buckets.push(`${d.getFullYear()}-Q${q}`);} }
  else if (freq === 'a'){ for (let i=MAX_POINTS-1;i>=0;i--){ const d = yearsAgo(i); buckets.push(String(d.getFullYear())); } }
  else { for (let i=MAX_POINTS-1;i>=0;i--){ const d = weeksAgo(i); const tmp=new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate())); const dayNum=(tmp.getUTCDay()+6)%7; tmp.setUTCDate(tmp.getUTCDate()-dayNum+3); const firstThu=new Date(Date.UTC(tmp.getUTCFullYear(),0,4)); const wk = 1 + Math.round(((tmp-firstThu)/86400000 -3)/7); buckets.push(`${tmp.getUTCFullYear()}-W${String(wk).padStart(2,'0')}`);} }
  return buckets;
}

/* ===== Fetch with proxies fallback (tries direct then proxies) ===== */
async function tryFetchWithProxies(origUrl){
  let lastErr = null;
  for (const mk of PROXIES){
    const url = mk(origUrl);
    try {
      const res = await fetch(url, { credentials:'omit' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      try { return JSON.parse(text); } catch(e){ try { return res.json(); } catch(e2){ throw new Error('parse error'); } }
    } catch(err){
      lastErr = err;
      // continue to next proxy
    }
  }
  throw lastErr || new Error('All proxies failed');
}

/* ===== Fetch FRED (no frequency param) - get native data, we'll aggregate client-side ===== */
function getStartByFreq(freq){
  if (freq === 'm') return iso(monthsAgo(MAX_POINTS));
  if (freq === 'q') return iso(monthsAgo(MAX_POINTS*3));
  if (freq === 'a') return iso(yearsAgo(MAX_POINTS));
  if (freq === 'w') return iso(weeksAgo(MAX_POINTS));
  return iso(yearsAgo(10));
}

async function fetchFRED(seriesId, freq){
  const start = getStartByFreq(freq);
  const end = iso(TODAY);
  const u = new URL('https://api.stlouisfed.org/fred/series/observations');
  u.searchParams.set('series_id', seriesId);
  u.searchParams.set('api_key', FRED_KEY);
  u.searchParams.set('file_type', 'json');
  u.searchParams.set('observation_start', start);
  u.searchParams.set('observation_end', end);
  u.searchParams.set('_v', String(Date.now()));
  try {
    const json = await tryFetchWithProxies(u.toString());
    if (!json || !json.observations) throw new Error('invalid payload');
    return json.observations.map(o => ({date: o.date, value: o.value === '.' ? null : Number(o.value)})).filter(x => Number.isFinite(x.value));
  } catch(err){
    logStatus(`${seriesId}: ${err.message}`, true);
    return null;
  }
}

/* ===== CoinGecko BTC fetch (preferred) ===== */
async function fetchBTCCoinGecko(freq){
  // request 'max' then bucket; it's OK, we will slice last MAX_POINTS buckets
  const url = `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=max`;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const json = await res.json();
    // json.prices = [[ts, price], ...]
    return json.prices.map(p => ({ date: new Date(p[0]).toISOString().split('T')[0], value: p[1] }));
  } catch(err){
    logStatus(`CoinGecko BTC: ${err.message}`, true);
    return null;
  }
}

/* ===== transforms (YoY) ===== */
function lagForFreq(freq){
  if (freq === 'm') return 12;
  if (freq === 'q') return 4;
  if (freq === 'a') return 1;
  if (freq === 'w') return 52;
  if (freq === 'd') return 365;
  return 12;
}

function computeYoY(series, lagCount){
  // series sorted ascending
  const out = [];
  for (let i=0;i<series.length;i++){
    if (i - lagCount >= 0){
      const cur = series[i].value;
      const prev = series[i - lagCount].value;
      out.push({date: series[i].date, value: (prev && prev !== 0) ? ((cur/prev - 1) * 100) : null});
    } else {
      out.push({date: series[i].date, value: null});
    }
  }
  return out;
}

/* ===== map series to bucket (EOP) ===== */
function mapSeriesToBucket(series, freq){
  const map = new Map();
  series.forEach(pt => {
    const k = toBucket(pt.date, freq);
    map.set(k, pt.value); // override so last date in bucket wins
  });
  return map;
}

/* ===== Chart rendering code ===== */
const chartRefs = {};
function toDataset(label, color, buckets, map, opts={}){
  return { label, data: buckets.map(b => map.has(b) ? map.get(b) : null), borderColor: color, tension:0.2, pointRadius:0, spanGaps:true, borderDash: opts.dash || [] };
}

async function drawGroup(canvasId, metas, freq){
  // special-case BTC (CoinGecko preferred)
  const isBTC = metas.length === 1 && metas[0].id === 'COINGECKO_BTC';
  let fetched = [];
  if (isBTC){
    const cg = await fetchBTCCoinGecko(freq);
    fetched = [cg];
  } else {
    // fetch each FRED series (native) in parallel
    const promises = metas.map(m => fetchFRED(m.id, freq));
    const results = await Promise.all(promises);
    fetched = results; // may contain nulls
  }

  // choose buckets from any real series if present, else generate
  const real = fetched.filter(x => Array.isArray(x) && x.length>0);
  let buckets;
  if (real.length > 0){
    const s = new Set();
    real.forEach(series => series.forEach(p => s.add(toBucket(p.date, freq))));
    let arr = sortBuckets(Array.from(s));
    if (arr.length > MAX_POINTS) arr = arr.slice(-MAX_POINTS);
    buckets = arr;
  } else {
    buckets = generateBucketsForFreq(freq);
  }

  // datasets
  const palette = ["#2563eb","#dc2626","#059669","#7c3aed","#f59e0b","#0ea5e9","#ef4444","#16a34a"];
  const datasets = [];
  for (let i=0;i<metas.length;i++){
    const meta = metas[i];
    const series = fetched[i];
    if (!series || series.length === 0){
      // mark no data -> dashed grey
      datasets.push(toDataset(meta.label + ' (no data)', '#9ca3af', buckets, new Map(), {dash:[6,6]}));
      continue;
    }
    let seriesToMap = series;
    if (meta.transform === 'yoy'){
      const lag = lagForFreq(meta.freq || 'm');
      // ensure sorted ascending
      seriesToMap = computeYoY(series, lag);
    }
    const map = mapSeriesToBucket(seriesToMap, freq);
    datasets.push(toDataset(meta.label, palette[i % palette.length], buckets, map));
  }

  // render with Chart.js
  const ctx = document.getElementById(canvasId).getContext('2d');
  if (chartRefs[canvasId]) chartRefs[canvasId].destroy();
  chartRefs[canvasId] = new Chart(ctx, {
    type:'line',
    data:{ labels: buckets, datasets },
    options:{
      responsive:true, maintainAspectRatio:false,
      interaction:{mode:'index',intersect:false},
      plugins:{
        legend:{position:'top'},
        tooltip:{callbacks:{
          label: function(context){
            const ds = context.dataset;
            const v = context.parsed.y;
            if (v === null || v === undefined) return ds.label + ': no data';
            if (/CPI|PCE|Core/i.test(ds.label)) return ds.label + ': ' + Number(v).toFixed(2) + '%';
            if (/Bitcoin|BTC|Gold|WTI|S&P|SP500|Price|USD|Crude/i.test(ds.label)) return ds.label + ': $' + Number(v).toLocaleString();
            return ds.label + ': ' + Number(v).toLocaleString();
          }
        }}
      },
      scales:{ x:{ grid:{display:false}, ticks:{maxRotation:0} }, y:{ grid:{color:'rgba(0,0,0,0.06)'}, ticks:{maxTicksLimit:6} } }
    }
  });
}

/* ===== Main loader ===== */
async function loadAll(){
  clearStatus();
  const freq = document.getElementById('timeframe').value; // m/q/a/w
  await drawGroup('inflationChart', SERIES.inflation, freq);
  await drawGroup('policyChart', SERIES.policy, freq);
  await drawGroup('moneyChart', SERIES.money, freq);
  await drawGroup('growthChart', SERIES.growth, freq);
  await drawGroup('sentimentChart', SERIES.sentiment, freq);
  await drawGroup('equityChart', SERIES.equity, freq);
  await drawGroup('commoditiesChart', SERIES.commodities, freq);
  await drawGroup('btcChart', SERIES.btc, freq);
  logStatus('Done ✔');
  setTimeout(()=>STATUS.classList.add('hidden'), 2000);
}

document.getElementById('timeframe').addEventListener('change', loadAll);
window.addEventListener('load', loadAll);
</script>
</body>
</html>
